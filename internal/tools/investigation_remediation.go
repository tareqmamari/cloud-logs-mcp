// Package tools provides MCP tool implementations for IBM Cloud Logs.
// This file implements remediation asset generation (alerts, dashboards, SOPs).
package tools

import (
	"encoding/json"
	"fmt"
	"strings"
)

// RemediationGenerator creates alerts and dashboards from incident context
type RemediationGenerator struct{}

// NewRemediationGenerator creates a new remediation generator
func NewRemediationGenerator() *RemediationGenerator {
	return &RemediationGenerator{}
}

// IncidentResponseAssets is the output of remediation generation
type IncidentResponseAssets struct {
	Alert              *AlertConfig        `json:"alert,omitempty"`
	Dashboard          *DashboardConfig    `json:"dashboard,omitempty"`
	SOPRecommendations []SOPRecommendation `json:"sop_recommendations,omitempty"`
}

// AlertConfig holds generated alert configuration
type AlertConfig struct {
	Name             string                 `json:"name"`
	Description      string                 `json:"description"`
	Condition        string                 `json:"condition"`
	Threshold        float64                `json:"threshold"`
	EvaluationWindow string                 `json:"evaluation_window"`
	Terraform        string                 `json:"terraform"`
	IBMCloudLogsJSON map[string]interface{} `json:"ibm_cloud_logs_json"`
}

// DashboardConfig holds generated dashboard configuration
type DashboardConfig struct {
	Name             string                 `json:"name"`
	Description      string                 `json:"description"`
	Widgets          []DashboardWidget      `json:"widgets"`
	IBMCloudLogsJSON map[string]interface{} `json:"ibm_cloud_logs_json"`
}

// DashboardWidget represents a dashboard widget
type DashboardWidget struct {
	Title string `json:"title"`
	Type  string `json:"type"`
	Query string `json:"query"`
}

// IncidentContext holds investigation findings for asset generation
type IncidentContext struct {
	RootCause         string
	AffectedServices  []string
	ErrorPatterns     []ErrorPattern
	MetricsOfInterest []string
}

// ErrorPattern represents a detected error pattern
type ErrorPattern struct {
	Pattern  string
	Count    int
	Severity string
}

// Generate creates all remediation assets from incident context
func (g *RemediationGenerator) Generate(ctx *IncidentContext, severity string) *IncidentResponseAssets {
	assets := &IncidentResponseAssets{
		SOPRecommendations: g.generateSOPs(ctx),
	}

	// Generate alert
	assets.Alert = g.generateAlert(ctx, severity)

	// Generate dashboard
	assets.Dashboard = g.generateDashboard(ctx)

	return assets
}

func (g *RemediationGenerator) generateAlert(ctx *IncidentContext, severity string) *AlertConfig {
	serviceName := "multiple-services"
	if len(ctx.AffectedServices) == 1 {
		serviceName = ctx.AffectedServices[0]
	}

	alertName := fmt.Sprintf("%s-error-rate-alert", sanitizeResourceName(serviceName))
	description := fmt.Sprintf("Alert for: %s", ctx.RootCause)

	// Build the alert condition based on affected services
	condition := g.buildAlertCondition(ctx)

	return &AlertConfig{
		Name:             alertName,
		Description:      description,
		Condition:        condition,
		Threshold:        5.0, // 5% error rate default
		EvaluationWindow: "5m",
		Terraform:        g.generateTerraform(alertName, description, condition, severity),
		IBMCloudLogsJSON: g.generateIBMCloudLogsAlertJSON(alertName, description, condition, severity),
	}
}

func (g *RemediationGenerator) buildAlertCondition(ctx *IncidentContext) string {
	conditions := []string{}

	for _, svc := range ctx.AffectedServices {
		conditions = append(conditions, fmt.Sprintf("$l.applicationname == '%s'", svc))
	}

	if len(conditions) > 0 {
		return fmt.Sprintf("(%s) && $m.severity >= 5", strings.Join(conditions, " || "))
	}

	return "$m.severity >= 5"
}

func (g *RemediationGenerator) generateTerraform(name, description, condition, severity string) string {
	severityMap := map[string]string{
		"critical": "CRITICAL",
		"high":     "ERROR",
		"medium":   "WARNING",
		"low":      "INFO",
	}

	tfSeverity := severityMap[severity]
	if tfSeverity == "" {
		tfSeverity = "ERROR"
	}

	resourceName := sanitizeResourceName(name)

	return fmt.Sprintf(`# Terraform configuration for IBM Cloud Logs alert
# Generated by Smart Investigation Tool

resource "ibm_logs_alert" "%s" {
  name        = "%s"
  description = "%s"
  severity    = "%s"
  is_active   = true

  condition {
    logs_ratio_threshold {
      rules {
        condition {
          condition_type = "MORE_THAN"
          threshold      = 5
          time_window    = "FIVE_MINUTES"
        }
        override {
          priority = "P2"
        }
      }

      query_1 {
        search_query {
          query = "%s"
        }
      }

      query_2 {
        search_query {
          query = "$m.severity >= 1"
        }
      }
    }
  }

  notification_groups {
    notifications {
      notify_on       = ["Triggered"]
      integration_id  = var.notification_integration_id
    }
  }
}

variable "notification_integration_id" {
  description = "Integration ID for alert notifications (Slack, PagerDuty, etc.)"
  type        = string
}

output "%s_alert_id" {
  description = "The ID of the created alert"
  value       = ibm_logs_alert.%s.id
}
`, resourceName, name, escapeForTerraform(description), tfSeverity,
		escapeForTerraform(condition), resourceName, resourceName)
}

func (g *RemediationGenerator) generateIBMCloudLogsAlertJSON(name, description, condition, severity string) map[string]interface{} {
	return map[string]interface{}{
		"name":        name,
		"description": description,
		"is_active":   true,
		"severity":    strings.ToUpper(severity),
		"condition": map[string]interface{}{
			"type": "logs_ratio_threshold",
			"parameters": map[string]interface{}{
				"threshold":   5,
				"time_window": "5m",
				"query_1":     condition,
				"query_2":     "$m.severity >= 1",
				"ratio":       "query_1 / query_2 * 100",
				"condition":   "MORE_THAN",
				"group_by":    []string{},
				"manage_undetected_values": map[string]interface{}{
					"enable_triggering_on_undetected_values": false,
				},
			},
		},
		"notifications": map[string]interface{}{
			"on_triggered": true,
			"on_resolved":  true,
			"notify_every": "10m",
			"channels":     []interface{}{},
		},
	}
}

func (g *RemediationGenerator) generateDashboard(ctx *IncidentContext) *DashboardConfig {
	serviceName := "System"
	if len(ctx.AffectedServices) == 1 {
		serviceName = ctx.AffectedServices[0]
	}

	dashboardName := fmt.Sprintf("%s - Incident Analysis", serviceName)

	widgets := g.generateWidgets(ctx)

	return &DashboardConfig{
		Name:             dashboardName,
		Description:      fmt.Sprintf("Dashboard for investigating: %s", ctx.RootCause),
		Widgets:          widgets,
		IBMCloudLogsJSON: g.generateIBMCloudLogsDashboardJSON(dashboardName, widgets, ctx),
	}
}

func (g *RemediationGenerator) generateWidgets(ctx *IncidentContext) []DashboardWidget {
	widgets := []DashboardWidget{}
	serviceFilter := ""

	if len(ctx.AffectedServices) > 0 {
		filters := []string{}
		for _, svc := range ctx.AffectedServices {
			filters = append(filters, fmt.Sprintf("$l.applicationname == '%s'", svc))
		}
		serviceFilter = fmt.Sprintf(" && (%s)", strings.Join(filters, " || "))
	}

	// Error rate over time
	widgets = append(widgets, DashboardWidget{
		Title: "Error Rate Over Time",
		Type:  "line_chart",
		Query: fmt.Sprintf(`source logs
| filter $m.severity >= 5%s
| groupby bucket($m.timestamp, 1m) as time_bucket
| calculate count() as errors`, serviceFilter),
	})

	// Error distribution by service
	widgets = append(widgets, DashboardWidget{
		Title: "Errors by Service",
		Type:  "pie_chart",
		Query: fmt.Sprintf(`source logs
| filter $m.severity >= 5%s
| groupby $l.applicationname
| calculate count() as errors`, serviceFilter),
	})

	// Latency percentiles (if service has duration data)
	widgets = append(widgets, DashboardWidget{
		Title: "Latency Distribution",
		Type:  "line_chart",
		Query: fmt.Sprintf(`source logs
| filter $d.duration_ms.exists()%s
| groupby bucket($m.timestamp, 1m) as time_bucket
| calculate
    avg($d.duration_ms) as avg_latency,
    percentile($d.duration_ms, 95) as p95,
    percentile($d.duration_ms, 99) as p99`, serviceFilter),
	})

	// Error messages table
	widgets = append(widgets, DashboardWidget{
		Title: "Top Error Messages",
		Type:  "data_table",
		Query: fmt.Sprintf(`source logs
| filter $m.severity >= 5%s
| groupby $d.message
| calculate count() as occurrences
| sortby -occurrences
| limit 10`, serviceFilter),
	})

	// Errors by subsystem
	widgets = append(widgets, DashboardWidget{
		Title: "Errors by Subsystem",
		Type:  "bar_chart",
		Query: fmt.Sprintf(`source logs
| filter $m.severity >= 5%s
| groupby $l.subsystemname
| calculate count() as errors
| sortby -errors
| limit 10`, serviceFilter),
	})

	return widgets
}

func (g *RemediationGenerator) generateIBMCloudLogsDashboardJSON(name string, widgets []DashboardWidget, ctx *IncidentContext) map[string]interface{} {
	dashboardWidgets := []map[string]interface{}{}

	for i, w := range widgets {
		dashboardWidgets = append(dashboardWidgets, map[string]interface{}{
			"id":    fmt.Sprintf("widget_%d", i),
			"title": w.Title,
			"type":  w.Type,
			"position": map[string]interface{}{
				"x":      (i % 2) * 6,
				"y":      (i / 2) * 4,
				"width":  6,
				"height": 4,
			},
			"query": map[string]interface{}{
				"syntax": "dataprime",
				"query":  w.Query,
			},
		})
	}

	return map[string]interface{}{
		"name":        name,
		"description": fmt.Sprintf("Auto-generated incident analysis dashboard for: %s", ctx.RootCause),
		"folder_id":   nil,
		"layout": map[string]interface{}{
			"sections": []map[string]interface{}{
				{
					"id":   "main",
					"rows": []map[string]interface{}{},
				},
			},
		},
		"widgets":   dashboardWidgets,
		"variables": []interface{}{},
		"filters":   []interface{}{},
		"time_frame": map[string]interface{}{
			"relative": "last_1_hour",
		},
	}
}

func (g *RemediationGenerator) generateSOPs(ctx *IncidentContext) []SOPRecommendation {
	sops := []SOPRecommendation{}

	rootCauseLower := strings.ToLower(ctx.RootCause)

	// Match patterns to SOPs
	sopPatterns := map[string]SOPRecommendation{
		"timeout": {
			Trigger: "Timeout errors detected",
			Procedure: `1. Check downstream service health
2. Review network latency metrics
3. Verify connection pool settings
4. Check for resource contention`,
			Escalation: "If unresolved in 15 minutes, escalate to Platform team",
		},
		"memory": {
			Trigger: "Memory pressure detected",
			Procedure: `1. Check container memory limits (kubectl top pods)
2. Review JVM heap settings (-Xmx)
3. Check for memory leaks in recent deployments
4. Consider horizontal scaling`,
			Escalation: "If OOMKilled, escalate to Development team",
		},
		"connection": {
			Trigger: "Connection errors detected",
			Procedure: `1. Verify database/cache connectivity
2. Check connection pool exhaustion
3. Review max_connections settings
4. Check for network policy changes`,
			Escalation: "If database-related, escalate to DBA team",
		},
		"auth": {
			Trigger: "Authentication failures detected",
			Procedure: `1. Verify service credentials
2. Check IAM policy changes
3. Review token expiration
4. Check for certificate issues`,
			Escalation: "If security incident suspected, escalate to Security team immediately",
		},
		"rate": {
			Trigger: "Rate limiting detected",
			Procedure: `1. Identify the source of excessive requests
2. Review rate limit configurations
3. Check for retry storms
4. Implement exponential backoff`,
			Escalation: "If business-critical, escalate to Engineering lead",
		},
	}

	for pattern, sop := range sopPatterns {
		if strings.Contains(rootCauseLower, pattern) {
			sops = append(sops, sop)
		}
	}

	// Add generic SOP if no specific match
	if len(sops) == 0 {
		sops = append(sops, SOPRecommendation{
			Trigger: "Generic error pattern",
			Procedure: `1. Review error logs for patterns
2. Check recent deployments
3. Verify infrastructure health
4. Review dependent service status`,
			Escalation: "Escalate based on impact severity",
		})
	}

	return sops
}

// FormatAssetsAsMarkdown formats the remediation assets as markdown
func FormatAssetsAsMarkdown(assets *IncidentResponseAssets) string {
	var sb strings.Builder

	if assets.Alert != nil {
		sb.WriteString("### Alert Configuration\n\n")
		sb.WriteString(fmt.Sprintf("**Name:** %s\n", assets.Alert.Name))
		sb.WriteString(fmt.Sprintf("**Description:** %s\n", assets.Alert.Description))
		sb.WriteString(fmt.Sprintf("**Condition:** `%s`\n", assets.Alert.Condition))
		sb.WriteString(fmt.Sprintf("**Threshold:** %.1f%%\n", assets.Alert.Threshold))
		sb.WriteString(fmt.Sprintf("**Window:** %s\n\n", assets.Alert.EvaluationWindow))

		sb.WriteString("<details>\n<summary>Terraform Configuration</summary>\n\n```hcl\n")
		sb.WriteString(assets.Alert.Terraform)
		sb.WriteString("\n```\n</details>\n\n")

		jsonBytes, _ := json.MarshalIndent(assets.Alert.IBMCloudLogsJSON, "", "  ")
		sb.WriteString("<details>\n<summary>IBM Cloud Logs Alert JSON</summary>\n\n```json\n")
		sb.WriteString(string(jsonBytes))
		sb.WriteString("\n```\n</details>\n\n")
	}

	if assets.Dashboard != nil {
		sb.WriteString("### Dashboard Configuration\n\n")
		sb.WriteString(fmt.Sprintf("**Name:** %s\n", assets.Dashboard.Name))
		sb.WriteString(fmt.Sprintf("**Widgets:** %d\n\n", len(assets.Dashboard.Widgets)))

		for _, w := range assets.Dashboard.Widgets {
			sb.WriteString(fmt.Sprintf("- **%s** (%s)\n", w.Title, w.Type))
		}
		sb.WriteString("\n")

		jsonBytes, _ := json.MarshalIndent(assets.Dashboard.IBMCloudLogsJSON, "", "  ")
		sb.WriteString("<details>\n<summary>IBM Cloud Logs Dashboard JSON</summary>\n\n```json\n")
		sb.WriteString(string(jsonBytes))
		sb.WriteString("\n```\n</details>\n\n")
	}

	if len(assets.SOPRecommendations) > 0 {
		sb.WriteString("### Standard Operating Procedures\n\n")
		for _, sop := range assets.SOPRecommendations {
			sb.WriteString(fmt.Sprintf("**Trigger:** %s\n\n", sop.Trigger))
			sb.WriteString(fmt.Sprintf("**Procedure:**\n%s\n\n", sop.Procedure))
			sb.WriteString(fmt.Sprintf("_Escalation: %s_\n\n---\n\n", sop.Escalation))
		}
	}

	return sb.String()
}

// Helper functions

func sanitizeResourceName(name string) string {
	name = strings.ToLower(name)
	name = strings.ReplaceAll(name, "-", "_")
	name = strings.ReplaceAll(name, " ", "_")
	name = strings.ReplaceAll(name, "/", "_")
	return name
}

func escapeForTerraform(s string) string {
	s = strings.ReplaceAll(s, "\\", "\\\\")
	s = strings.ReplaceAll(s, "\"", "\\\"")
	return s
}
